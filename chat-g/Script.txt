Para criar uma aplicação de chat
que contenha as seguintes funções

Mandar mensagem um pra outro,
Notificações,
Visto e não visto,
Limite de mensagens carregadas de 50 por vez,
Quando chegar na Mensagem 51 carregar até a 100° mensagem,


Roteiro
Criar context

import React, { usaeState, createContext } from " React";

export const Context = createContext(); '''isso é necessario, tenho que entrender'''


export const ContextProvider = (props) => {
	const [username, setUserName ] = useState("")
	const [secret, setSecret] = useState("");
	const value = {
		username,  ´´Ísso aqui são as variaveis que quero passar para aplicação toda´´
		setUsername,
		setSecret,
	};
	return <Context.Provider value={value}>{props.children}</Context.Provider>;

}
para fazer isso tudo funcionar eu preciso englobar a aplicação com o context lá no layout.tsx , primeiramente apagando tudo que ele está retornando e substituindo pelo seguinte: 

import { ContextProvider } from "../context/Context"

...codigo lá...

    <ContextProvider>
        <codigo>
    </ContextProvider>
Isso vai informando a todos


Login 
Passo 1
Criar a pagina Login.
app/login/page.tsx.

Codigo a ser analisado

"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { auth } from '../../firebaseConfig'; // Sua configuração do Firebase
import { GoogleAuthProvider, signInWithPopup } from 'firebase/auth';

export default function LoginPage() {
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  // Função para lidar com o login do Google
  const handleGoogleLogin = async () => {
    setError(null);
    const provider = new GoogleAuthProvider();

    try {
      // Abre um pop-up para o usuário fazer o login com a conta do Google
      await signInWithPopup(auth, provider);

      // Se o login for bem-sucedido, redireciona o usuário para a página inicial
      router.push('/');

    } catch (err: any) {
      // Captura e exibe erros
      console.error(err);
      if (err.code === 'auth/popup-closed-by-user') {
        setError('O login foi cancelado.');
      } else {
        setError('Ocorreu um erro no login com o Google. Tente novamente.');
      }
    }
  };

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', minHeight: '100vh', padding: '20px' }}>
      <h1>Acesse sua Conta</h1>
      <button 
        onClick={handleGoogleLogin} 
        style={{ padding: '10px 20px', fontSize: '16px', cursor: 'pointer' }}
      >
        Entrar com o Google
      </button>
      {error && <p style={{ color: 'red', marginTop: '10px' }}>{error}</p>}
    </div>
  );
}




nela vai ter o login.

Passo 2
Crie o context de autenticação.

Vamos criar um context oara guardar a informação do usuario cara. 
app/context/AuthContext.tsx

codigo para ser estudado

"use client";

import { createContext, useContext, useEffect, useState } from "react";
import { auth } from "../../firebaseConfig"; // Importa a sua instância do Firebase
import { onAuthStateChanged, User } from "firebase/auth";

// 1. Criação do Contexto
export const AuthContext = createContext<User | null>(null);

// 2. Criação do Provedor (Provider)
export const AuthContextProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  // 3. Listener do Firebase
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      // Quando o estado de autenticação muda, esta função é chamada.
      setUser(currentUser);
      setLoading(false);
    });

    // Função de "limpeza" para parar o listener quando o componente for desmontado
    return () => unsubscribe();
  }, []); // O array vazio indica que este efeito roda apenas uma vez

  return (
    // 4. Provedor que torna o usuário e o estado de carregamento disponíveis
    <AuthContext.Provider value={user}>
      {loading ? <div>Carregando...</div> : children}
    </AuthContext.Provider>
  );
};

// 5. Hook para uso fácil
export const useAuth = () => {
  return useContext(AuthContext);
};



Passo 3 crie o midleware, ele seria tipo um porteiro para verificar se você tá logado ou não
Crie ele fora do app como midleware.ts 
e te jogar na página certa


codigo a ser estudado: 

// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// 1. Defina as rotas que não precisam de autenticação
const publicPaths = ['/login'];

// Esta é a sua lógica de autenticação.
// Em um cenário real, você verificaria um token de sessão ou cookie do Firebase aqui.
const isAuthenticated = (req: NextRequest) => {
  // Lógica de verificação do token
  // Exemplo: const token = req.cookies.get('__session');
  // return !!token; 
  
  // Por enquanto, vamos retornar true para que o código compile,
  // mas aqui você faria a checagem real com o token de sessão do Firebase.
  return true; 
};

export function middleware(request: NextRequest) {
  const path = request.nextUrl.pathname;
  const isPublicPath = publicPaths.includes(path);
  const userIsAuthenticated = isAuthenticated(request);

  // 2. Condição de redirecionamento
  if (!userIsAuthenticated && !isPublicPath) {
    // Se o usuário não está autenticado E a rota não é pública, redirecionar para a página de login.
    const loginUrl = new URL('/login', request.url);
    return NextResponse.redirect(loginUrl);
  }

  // Se o usuário está autenticado E está tentando acessar a página de login, redirecioná-lo para a home.
  if (userIsAuthenticated && isPublicPath) {
    const homeUrl = new URL('/', request.url);
    return NextResponse.redirect(homeUrl);
  }

  // 3. Se tudo estiver certo, permita a requisição
  return NextResponse.next();
}

// 4. Defina as rotas que o middleware deve proteger
export const config = {
  matcher: [
    '/',
    '/chat/:path*', // Protege todas as rotas dentro da pasta chat (ex: /chat, /chat/settings, etc.)
    '/profile', // Protege uma rota específica
    '/login' // Protege a rota de login para usuários já logados
  ],
};